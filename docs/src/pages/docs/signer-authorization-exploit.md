---
title: Signer Authorization Exploit
description: Anchor - In this Chapter of Common Security Exploits of Sealevel, or Sealevel Attacks, we do a deep dive on how malicious actors can try to spoof Signer Authorization to exploit your program.
---
## Overview
The signer authorization exploit is a security vulenerability where a program's "authority" is not properly validated.
This means that a user can pretend to be the owner of an account when they are not.
The solution around this is to make sure that whenever you are handling an instruction that should be done by the "authority" account, that you make sure it signs the transaction.
We can take a look at the code below to see an example.

### Insecure

```rust
use anchor_lang::prelude::*;

declare_id!("Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS");
#[program]
pub mod signer_authorization_insecure {
    use super::*;

    pub fn log_message(ctx: Context<LogMessage>) -> ProgramResult {
        msg!("GM {}", ctx.accounts.authority.key().to_string());
        Ok(())
    }
}

#[derive(Accounts)]
pub struct LogMessage<'info> {
    authority: AccountInfo<'info>,
}
```

Here you can see our `LogMessage` account has an `authority` key. However, this is prone to the signer authorization exploit.
That is because you can include any account in your transaction, as long as you aren't signing on behalf of the account.
In the next example you will see what a potential work-around is to ensure that the `authority` is also the signer.

### Secure
```rust
use anchor_lang::prelude::*;

declare_id!("Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS");

#[program]
pub mod signer_authorization_secure {
    use super::*;

    pub fn log_message(ctx: Context<LogMessage>) -> ProgramResult {
        if !ctx.accounts.authority.is_signer {
            return Err(ProgramError::MissingRequiredSignature);
        }
        msg!("GM {}", ctx.accounts.authority.key().to_string());
        Ok(())
    }
}

#[derive(Accounts)]
pub struct LogMessage<'info> {
    authority: AccountInfo<'info>,
}
```
This example does not fall prey to the same exploit. That is because in the `log_message` function we have access to the account information through the `ctx` argument.
In this case, we check that the authority's key is the one that signs the message with the line `ctx.accounts.authority.is_signer`.
Then if it is, we go on to sucessfully log the message. While this works, there is a more Anchor-esque approach that we can take a look at.

### Recommended
```rust
use anchor_lang::prelude::*;

declare_id!("Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS");

#[program]
pub mod signer_authorization_recommended {
    use super::*;

    pub fn log_message(ctx: Context<LogMessage>) -> ProgramResult {
        msg!("GM {}", ctx.accounts.authority.key().to_string());
        Ok(())
    }
}

#[derive(Accounts)]
pub struct LogMessage<'info> {
    authority: Signer<'info>,
}
```
Not only does this snippet provide us all of the safeguads that we require, it removes some lines of code for us.
This is the most idiomatic Anchor code that accomplishes this goal.
The `Signer` type will check that the `authority`'s PubKey is the one signing the transaction.
That means we can focus on only our business logic within the program, and let the types do the validation for us.

