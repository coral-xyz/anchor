---
title: Bump Seed Canonicalization Exploit
description: Anchor - In this Chapter of Common Security Exploits of Sealevel, or Sealevel Attacks, we do a deep dive on how malicious actors can use user-provided bumps to exploit your program if you do not properly validate the bump seed.
---

## Overview
The bump seed canonicalization vulnerability is when your program does not properly validate the bump or seed used to interact with a PDA.
If you do not properly check this, users could pass in a seed that will interact with a different PDA than expected.
This could allow users to arbitrarily interact with your program's state/data.
See the example below.
### Insecure

```rust
use anchor_lang::prelude::*;

declare_id!("Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS");

#[program]
pub mod bump_seed_canonicalization_insecure {
    use super::*;

    pub fn set_value(ctx: Context<BumpSeed>, key: u64, new_value: u64, bump: u8) -> ProgramResult {
        let address =
            Pubkey::create_program_address(&[key.to_le_bytes().as_ref(), &[bump]], ctx.program_id)?;
        if address != ctx.accounts.data.key() {
            return Err(ProgramError::InvalidArgument);
        }

        ctx.accounts.data.value = new_value;

        Ok(())
    }
}

#[derive(Accounts)]
pub struct BumpSeed<'info> {
    data: Account<'info, Data>,
}

#[account]
pub struct Data {
    value: u64,
}
```
This code is insecure as we are using `create_program_address` on a user-provided bump.
This could operate on any PDA that is generated by the combination of seeds + program ID.
instead, use `find_program_address`, and validate that the bump the user provided is the one you expected.

### Secure

```rust
use anchor_lang::prelude::*;

declare_id!("Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS");

#[program]
pub mod bump_seed_canonicalization_secure {
    use super::*;

    pub fn set_value_secure(
        ctx: Context<BumpSeed>,
        key: u64,
        new_value: u64,
        bump: u8,
    ) -> ProgramResult {
        let (address, expected_bump) =
            Pubkey::find_program_address(&[key.to_le_bytes().as_ref()], ctx.program_id);

        if address != ctx.accounts.data.key() {
            return Err(ProgramError::InvalidArgument);
        }
        if expected_bump != bump {
            return Err(ProgramError::InvalidArgument);
        }

        ctx.accounts.data.value = new_value;
        Ok(())
    }
}

#[derive(Accounts)]
pub struct BumpSeed<'info> {
    data: Account<'info, Data>,
}

#[account]
pub struct Data {
    value: u64,
}
```
Here you can see our use of `find_program_address` to ensure we are not creating any new/unexpected PDAs.
Then we also check to make sure the key and bump that the user provided match the PDA that we found.
However, we can move this logic into our account structs, and let them do the validation for us.

### Recommended
```rust
use anchor_lang::prelude::*;

declare_id!("Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS");

#[program]
pub mod bump_seed_canonicalization_recommended {
    use super::*;

    pub fn set_value(ctx: Context<BumpSeed>, key: u64, new_value: u64) -> ProgramResult {
        ctx.accounts.data.value = new_value;
        Ok(())
    }
}

#[derive(Accounts)]
#[instruction(key: u64)]
pub struct BumpSeed<'info> {
    // Note a subtle pattern that is not displayed here.
    //
    // Usually, the usage of PDAs is broken into two parts:
    //
    // 1) allocation via `#[account(init, seeds = [...], bump)]`
    // 2) using the account via `#[account(seeds = [...], bump = data.bump)]
    //
    // When using a PDA, it's usually recommend to store the bump seed in the
    // account data, so that you can use it as demonstrated in 2), which will
    // provide a more efficient check.
    #[account(seeds = [key.to_le_bytes().as_ref()], bump)]
    data: Account<'info, Data>,
}

#[account]
pub struct Data {
    value: u64,
}
```
Here you can see that in the program logic we are no longer doing any validation.
This makes it much easier to see what is going on in the program, without all of the noise that data validation causes.
In this instance, we use an inert attribute to check the seeds used in the account's PDA.

Worth noting is the lack of bump stored in the `Data` account.
To see how programs usually interact with and store PDAs you can check out [this example](/docs/pdas#hashmap-like-structures-using-pd-as)
