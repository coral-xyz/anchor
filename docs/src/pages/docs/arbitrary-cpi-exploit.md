---
title: Arbitrary CPI exploit
description: Anchor - In this Chapter of Common Security Exploits of Sealevel, or Sealevel Attacks, we do a deep dive on how malicious actors can invoke arbitrary programs using CPI to breach your security.
---

## Overview
The arbitrary cpi vulnerability is when your program does not properly validate the programm that it is invoking.
When you do not properly check the program's address, you could potentially call *any* program, which could have severe consequences.
See the example below.
### Insecure

```rust
use anchor_lang::prelude::*;
use anchor_lang::solana_program;

declare_id!("Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS");

#[program]
pub mod arbitrary_cpi_insecure {
    use super::*;

    pub fn cpi(ctx: Context<Cpi>, amount: u64) -> ProgramResult {
        solana_program::program::invoke(
            &spl_token::instruction::transfer(
                ctx.accounts.token_program.key,
                ctx.accounts.source.key,
                ctx.accounts.destination.key,
                ctx.accounts.authority.key,
                &[],
                amount,
            )?,
            &[
                ctx.accounts.source.clone(),
                ctx.accounts.destination.clone(),
                ctx.accounts.authority.clone(),
            ],
        )
    }
}

#[derive(Accounts)]
pub struct Cpi<'info> {
    source: AccountInfo<'info>,
    destination: AccountInfo<'info>,
    authority: AccountInfo<'info>,
    token_program: AccountInfo<'info>,
}
```
This code is insecure because we are invoking a program that the user passed in.
Any data that is inputted by a user needs to be validated.
To patch this you need to check that that the *expected* program's address is the same as the one the user passed in.

### Secure

```rust
use anchor_lang::prelude::*;
use anchor_lang::solana_program;

declare_id!("Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS");

#[program]
pub mod arbitrary_cpi_secure {
    use super::*;

    pub fn cpi_secure(ctx: Context<Cpi>, amount: u64) -> ProgramResult {
        // Make sure the program's address matches our user's passed in program.
        if &spl_token::ID != ctx.accounts.token_program.key {
            return Err(ProgramError::IncorrectProgramId);
        }
        solana_program::program::invoke(
            &spl_token::instruction::transfer(
                ctx.accounts.token_program.key,
                ctx.accounts.source.key,
                ctx.accounts.destination.key,
                ctx.accounts.authority.key,
                &[],
                amount,
            )?,
            &[
                ctx.accounts.source.clone(),
                ctx.accounts.destination.clone(),
                ctx.accounts.authority.clone(),
            ],
        )
    }
}

#[derive(Accounts)]
pub struct Cpi<'info> {
    source: AccountInfo<'info>,
    destination: AccountInfo<'info>,
    authority: AccountInfo<'info>,
    token_program: AccountInfo<'info>,
}
```
This is now secured since we validated that the data matches our expected values.
However, using Anchor we can clean this up a bit.

### Recommended
```rust
use anchor_lang::prelude::*;
use anchor_spl::token::{self, Token, TokenAccount};

declare_id!("Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS");

#[program]
pub mod arbitrary_cpi_recommended {
    use super::*;

    pub fn cpi(ctx: Context<Cpi>, amount: u64) -> ProgramResult {
        token::transfer(ctx.accounts.transfer_ctx(), amount)
    }
}

#[derive(Accounts)]
pub struct Cpi<'info> {
    source: Account<'info, TokenAccount>,
    destination: Account<'info, TokenAccount>,
    authority: Signer<'info>,
    token_program: Program<'info, Token>,
}

impl<'info> Cpi<'info> {
    pub fn transfer_ctx(&self) -> CpiContext<'_, '_, '_, 'info, token::Transfer<'info>> {
        let program = self.token_program.to_account_info();
        let accounts = token::Transfer {
            from: self.source.to_account_info(),
            to: self.destination.to_account_info(),
            authority: self.authority.to_account_info(),
        };
        CpiContext::new(program, accounts)
    }
}
```
Here you can see that in the program logic we are no longer doing any validation.
This makes it much easier to see what is going on in the program, without all of the noise that data validation causes.
In this instance, we use Anchor's wrapper around the SPL token program to check everything.

Another thing to note is that we've further secured our program by implementing the `transfer_ctx` function for our `Cpi` account struct.
This gives us full confidence that we know the data that we are be working with.

Not only do we make use of the `Program` struct for the `token_program`, but we also make use of the `Account` struct to make sure that the `source` and `destination` are actually token accounts.
While Anchor has an already existing wrapper for the SPL token program, you can see how to implement this yourself for other non-anchor programs that you want to interact with [here](https://docs.rs/anchor-lang/latest/anchor_lang/accounts/account/struct.Account.html#using-account-with-non-anchor-programs).