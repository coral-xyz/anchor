---
title: Owner Checks Exploit
description: In this page we go through several examples on how you can exploit a program through an Owner Check vulnerability. The Reader is then shown how to patch the insecure code.
---

## Overview
The owner check vulnerability is when your program does not properly check the owner of the accout you work working with.
When you do not validate the owner of an account you open yourself up to this potentially devestating vulnerability.
When the owner is not who you expect it to be, your program's data can change beneath you unexpectedly, or grant unintended privileges to a rogue actor.
See the example below.
### Insecure

```rust
use anchor_lang::prelude::*;
use anchor_lang::solana_program::program_error::ProgramError;
use anchor_lang::solana_program::program_pack::Pack;
use spl_token::state::Account as SplTokenAccount;

declare_id!("Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS");

#[program]
pub mod owner_checks_insecure {
    use super::*;

    pub fn log_message(ctx: Context<LogMessage>) -> ProgramResult {
        let token = SplTokenAccount::unpack(&ctx.accounts.token.data.borrow())?;
        if ctx.accounts.authority.key != &token.owner {
            return Err(ProgramError::InvalidAccountData);
        }
        msg!("Your account balance is: {}", token.amount);
        Ok(())
    }
}

#[derive(Accounts)]
pub struct LogMessage<'info> {
    token: AccountInfo<'info>,
    authority: Signer<'info>,
}
```
This code is insecure because we do not check that the `token` account is owned by the SPL Token Program.
To patch it we will need need to make sure that we are validating that key piece of data.

### Secure

```rust
use anchor_lang::prelude::*;
use anchor_lang::solana_program::program_error::ProgramError;
use anchor_lang::solana_program::program_pack::Pack;
use spl_token::state::Account as SplTokenAccount;

declare_id!("Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS");

#[program]
pub mod owner_checks_secure {
    use super::*;

    pub fn log_message(ctx: Context<LogMessage>) -> ProgramResult {
        let token = SplTokenAccount::unpack(&ctx.accounts.token.data.borrow())?;
        if ctx.accounts.token.owner != &spl_token::ID {
            return Err(ProgramError::InvalidAccountData);
        }
        if ctx.accounts.authority.key != &token.owner {
            return Err(ProgramError::InvalidAccountData);
        }
        msg!("Your account balance is: {}", token.amount);
        Ok(())
    }
}

#[derive(Accounts)]
pub struct LogMessage<'info> {
    token: AccountInfo<'info>,
    authority: Signer<'info>,
}
```
This is now secured since we validated that the token owner is the SPL Token Program.
But this makes our programs a bit noisy.
Anchor provides us the ability to do this validation inside our `LogMessage` struct, which cleans up our program's code.

### Recommended
```rust
use anchor_lang::prelude::*;
use anchor_spl::token::TokenAccount;

declare_id!("Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS");

#[program]
pub mod owner_checks_recommended {
    use super::*;

    pub fn log_message(ctx: Context<LogMessage>) -> ProgramResult {
        msg!("Your account balance is: {}", ctx.accounts.token.amount);
        Ok(())
    }
}

#[derive(Accounts)]
pub struct LogMessage<'info> {
    #[account(constraint = authority.key == &token.owner)]
    token: Account<'info, TokenAccount>,
    authority: Signer<'info>,
}
```
Here you can see that in the program logic we are no longer doing any validation.
This makes it much easier to see what is going on in the program, without all of the noise that data validation causes.
Validation has moved from the program to `LogMessage`.

We have imported the `TokenAccount` which we use in place of the generic `AccountInfo`.
This will check that the owner of the `TokenAccount` is equal to the SPL Token Program.
