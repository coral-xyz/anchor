---
title: Duplicate Mutable Accounts Exploit
description: Anchor - In this Chapter of Common Security Exploits of Sealevel, or Sealevel Attacks, we do a deep dive on how malicious actors can use duplicate mutable accounts to exploit your program..
---

## Overview
The duplicate mutable accounts vulnerability is when your program does not properly validate that two accounts are different.
When you do not properly validate these inputs, you could have unintended consequences.
See the example below.
### Insecure

```rust
use anchor_lang::prelude::*;

declare_id!("Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS");

#[program]
pub mod duplicate_mutable_accounts_insecure {
    use super::*;

    pub fn update(ctx: Context<Update>, a: u64, b: u64) -> ProgramResult {
        let user_a = &mut ctx.accounts.user_a;
        let user_b = &mut ctx.accounts.user_b;

        user_a.data = a;
        user_b.data = b;
        Ok(())
    }
}

#[derive(Accounts)]
pub struct Update<'info> {
    user_a: Account<'info, User>,
    user_b: Account<'info, User>,
}

#[account]
pub struct User {
    data: u64,
}
```
This code above is insecure because there is nothing stopping `user_a` and `user_b` from being the exact same person.
Imagine setting up a multi-sig, but you could pass in the same wallet 5 times in a row without issue.
Any data that is inputted by a user needs to be validated.
To patch this you need to check that the accounts *are* in fact different.

### Secure

```rust
use anchor_lang::prelude::*;

declare_id!("Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS");

#[program]
pub mod duplicate_mutable_accounts_secure {
    use super::*;

    pub fn update(ctx: Context<Update>, a: u64, b: u64) -> ProgramResult {
        if ctx.accounts.user_a.key() == ctx.accounts.user_b.key() {
            return Err(ProgramError::InvalidArgument)
        }
        let user_a = &mut ctx.accounts.user_a;
        let user_b = &mut ctx.accounts.user_b;

        user_a.data = a;
        user_b.data = b;
        Ok(())
    }
}

#[derive(Accounts)]
pub struct Update<'info> {
    user_a: Account<'info, User>,
    user_b: Account<'info, User>,
}

#[account]
pub struct User {
    data: u64,
}
```
With this check in place, we can be sure that the two accounts are separate before we move forward.
But imagine if you had more than two accounts, your code would quickly bloat as you added all of the checks needed.
Using Anchor we can clean this up by moving the data validation from the program to the account structs.

### Recommended
```rust
use anchor_lang::prelude::*;

declare_id!("Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS");

#[program]
pub mod duplicate_mutable_accounts_recommended {
    use super::*;

    pub fn update(ctx: Context<Update>, a: u64, b: u64) -> ProgramResult {
        let user_a = &mut ctx.accounts.user_a;
        let user_b = &mut ctx.accounts.user_b;

        user_a.data = a;
        user_b.data = b;
        Ok(())
    }
}

#[derive(Accounts)]
pub struct Update<'info> {
    #[account(constraint = user_a.key() != user_b.key())]
    user_a: Account<'info, User>,
    user_b: Account<'info, User>,
}

#[account]
pub struct User {
    data: u64,
}
```
Here you can see that in the program logic we are no longer doing any validation.
We can rest assured knowing that the `Update` will make sure all of our data is valid before we move into the handler and begin assigning data to different accounts.
